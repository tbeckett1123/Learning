Logfile was created onThu 09/21/2006 at 11:00 PM

>>>type time	
The system cannot find the file specified.

>>>type time_log_final.txt
										
"Team Members:  Mark Rubenstein, Tim Beckett, Rodney Kincaid"										
"Assignment#: 1 , Report # Final"										
"Due Date:  Thursday, 9/21/2006"										
Instructor: Dr. Al Cripps										
										
										
Team assignments for this assignment.										
Team Leader: Mark Rubenstein										
Coder(s): Tim Beckett										
Tester(s):  Rodney Kincaid										
Documentor(s):  Tim Beckett										
										
										
										
Report#1 Estimated times for Assignment			Report#1 Actual times for Assignment							
Time to design and code an alpha copy: 35 hours			Time to design and code an alpha copy: 4.75 hours							
Time to test and debug: 14 hours			Time to test and debug: 0 hours							
Time to Document Code: 8 hours 			Time to Document Code: 0 hours 							
Time to produce final product for turn in: 4 hours			Time to produce final product for turn in: 0 hours							
     Total Estimated time (in hours): 61 hours			     Total Actual time (in hours): 4.75 hours							
										
Report#1 Summary of Team's efforts thus far										
"The team seems to work rather well together. Upon looking at our class, work, and life schedules we have decided"										
"that the coder and documenter for this segment will be To,, the debugger and tester will be Rodney, and I will be the team leader."										
We all decided that we would use e-mail as a primary form of communication and we would meet as frequently as needed.										
We will meet in the KOM most of the time and the library is our backup meeting place.										
Rodney e-mailed both of the other team members so we all had access to each others email address.										
We met and gave our her our input as to where we all saw the project going so far.										
We left with good feelings towards the group and hope that things will all work out with timing.										
										
Report#2 Estimated times for Assignment			Report#2 Actual times for Assignment							
Time to design and code an alpha copy: 35 hours			Time to design and code an alpha copy: 12 hours	
Time to test and debug: 14 hours			Time to test and debug: 1 hours	
Time to Document Code: 8 hours 			Time to Document Code: 0 hours 	
Time to produce final product for turn in: 4 hours			Time to produce final product for turn in: 0 hours	
     Total Estimated time (in hours): 61 hours			     Total Actual time (in hours): 17.75 hours	
				
Report#2 Summary of Team's efforts thus far				
"Not much to say here, Tim is going at it and Rodney is waiting on a alpha copy to start testing. Hopefully it will be up sometime Friday."				
				
Report#3 Estimated times for Assignment			Report#3 Actual times for Assignment	
Time to design and code an alpha copy: 35 hours			Time to design and code an alpha copy: 13.5 hours	
Time to test and debug: 14 hours			Time to test and debug: 4 hours	
Time to Document Code: 8 hours 			Time to Document Code: 1 hours 	
Time to produce final product for turn in: 4 hours			Time to produce final product for turn in: 0 hours	
     Total Estimated time (in hours): 61 hours			     Total Actual time (in hours): 36.25 hours	
				
Report#3 Summary of Team's efforts thus far				
"After class the group decided that we needed to re-thing our design. Tim was using a string, which Dr. Cripps mentioned would be a bad"				
thing down the road. So off we went from square one again.				
				
				
				
Report#Final Actual times for Assignment				
Time to design and code an alpha copy:    6.2 hours				
Time to test and debug:    11.8 hours         				11.8
Time to Document Code:        4 hours				4
Time to produce final product for turn in:   5.8 hours				5.8
     Total Estimated time (in hours):     60.45 hours				24.2
				
Report#Final Summary of Team's efforts thus far				
"We had a lot of finish work down to the last hour, Rodney did a great job of finding bugs and although Tim"				
"was about wore out, he came thru at the end. I actually erased the finished timelog and had to start over from "				
scratch. That explains the extra time for me to complete the project. I hope our product meets the needs as		
well as impresses you. :)		
		
Notes for Time Recording Log		
Report#:		
Assign#:		The report number related to the task being performed.
Student Name: 		The assignment number related to the task being performed.
Date:		 Name of the student.  Must be consistent within and from one assignment to next.
		The date in the form month/day/year you did some activity related to the assignment such as 
Starting Time:		"coding a routine, attending a lecture, documenting, designing, and discussing with team members."
		The time you started the current activity today (does not refer to
Ending Time:		" when you originally started working on a task, but when did you begin to devote additional time to it today)."
Estimated Interruption Time:		The time you stopped the activity.
		Any time lost due to interruptions such as those caused by phone calls (not related 
Percent of Activity Completed?:		"to the task), chatting with people, and break time."
Description of Activity:		Indicate whether you completed the task at hand.  Estimate the percentage of the task that was completed.
		 A description of the task being performed.  Provide information as to what you were doing.								
		"This is more than just ""programming/meeting"".  Tell what routine(s) and difficulties/successes."								
										
										
								Percentage of 		
Report#	Assgn#	Student Name	Date of work	Starting Time	Ending Time 	session total	Estimated Interruption Time	Activity Completed	Description of Activity	
1	1	Mark Rubenstein	9/12/2006	21:00	22:45	1:45		90	design alpha	
1	1	Rodney Kincaid	9/12/2006	21:00	22:30	1:30		90	design alpha	
1	1	Tim Beckett	9/12/2006	21:00	22:30	1:30		90	design alpha	
										
2	1	Tim Beckett	13-Sep	19:00	21:12	2:12		20	Alpha complete Got intial project setup + Addressed Design Issues	
2	1	Tim Beckett	14-Sep	8:00	10:50	2:50		40	Design Issues + Coding	
2	1	Tim Beckett	14-Sep	14:10	21:30	7:20		70	Design Issues + Coding + Debugging	
2	1	Mark Rubenstein	9/14/2006	21:00	21:15	0:15		100	timelog	
										
3	1	Tim Beckett	15-Sep	9:10	14:30	5:20		100	Design Issues + Coding + Debugging	
3	1	Rodney Kincaid	17-Sep	21:00	23:00	2:00		0:00	Debugging
3	1	Tim Beckett	18-Sep	9:00	12:00	3:00		100	Code changing for Debugger + added needed comments
3	1	Rodney Kincaid	18-Sep	17:30	18:30	1:00			Debugging
3	1	Rodney Kincaid	19-Sep	21:00	22:00	1:00			group consult
3	1	Mark Rubenstein	19-Sep	21:00	22:00	1:00			group consult
3	1	Tim Beckett	19-Sep	18:00	23:00	5:00		40	group consult and Re-Coding
3	1	Mark Rubenstein	9/19/2006	23:00	23:15	0:15		100	timelog

4	1	Tim Beckett	20-Sep	10:00	14:00	4:00		80	Re-Coding
4	1	Rodney Kincaid	9/20/2006	16:00	17:30	1:50			
4	1	Tim Beckett	21-Sep	17:00	19:00	2:00		100	Re-Coding
4	1	Rodney Kincaid	9/20/2006	18:00	21:00	3:00			
4	1	Tim Beckett	21-Sep	21:30	22:00	0:30		0:00	fixing problem
4	1	Rodney Kincaid	21-Sep	15:00	22:00	7:00			
4	1	Mark Rubenstein	9/21/2006	18:00	23:50	5:50		100	final timelog

>>>dir
 Volume in drive Z is users
 Volume Serial Number is E081-4A9A

 Directory of Z:\My Documents\groupCompiler\assign10\symbolexample\bin\Debug

09/21/2006  10:59 PM    <DIR>          .
09/21/2006  10:59 PM    <DIR>          ..
09/21/2006  11:00 PM             4,165 log.txt
09/21/2006  08:14 PM            20,480 symbolexample.exe
09/21/2006  08:14 PM            17,920 symbolexample.pdb
09/20/2006  05:10 PM             5,632 symbolexample.vshost.exe
09/21/2006  08:13 PM            20,480 SymbolTable.dll
09/21/2006  08:13 PM            26,112 SymbolTable.pdb
09/20/2006  05:11 PM               549 symbol_debug.txt
09/21/2006  10:53 PM             7,174 time_log_final.txt
               8 File(s)        102,512 bytes
               2 Dir(s)  55,518,883,840 bytes free

>>>type SymbolTable.cs
/* Programmer:          Timothy Beckett (Coder) */
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;

namespace SymbolTable
{
    /* Variable             Type                Purpose
     * hashSymbolTable      Hashtable           it is the hashtable
     * scopeTracker         SCOPE               it keep track of the current scope
     */
    public class classSymbolTable
    {
        public Hashtable hashSymbolTable = new Hashtable();
        public SCOPE scopeTracker = new SCOPE();

        
        /* The method will create a hash key given from the text read from the line from the file and the provided scope
         * it will force.
         */
        /* Variable             Type                Purpose
         * charArray            char[]              it is used as the parameter of string split method
         * strForceScope        string              it hold the scope to be used in the key
         * strArray             string[]            it is used to hold the substring generated by string split
         * strKey               string              it store the key that is generated
         * strPassLine          sting               it is the string read in from the file
         */
        public string hashKey(string strPassLine, string strForceScope)
        {
            string strKey = "";
            string[] strArray = new string[100];
            char[] charArray = new char[1];

            charArray[0] = ' ';

            //remove the command from the line read in
            strPassLine = strPassLine.Substring(2, strPassLine.Length - 2);

            strArray = strPassLine.Split(charArray); //split the passed line

            if (strArray[0] == "S")
            {
                strKey = strForceScope + strArray[3];
            }
            else
            {
                strKey = strForceScope + strArray[1];
            }

            return strKey;

        }

        /* creates a hash key. this is ment to be used the first time you create a hash key. 
         * it creates a key from the line read in from the file. if no scope is provided then the current
         * scope is used.
         */
        /* Variable             Type                Purpose
         * charArray            char[]              it is used as the parameter of string split method
         * strArray             string[]            it is used to hold the substring generated by string split
         * strKey               string              it store the key that is generated
         * strPassLine          string              it is the string read in from the file
         */
        public string hashKey(string strPassLine)
        {
            string strKey = "";
            string[] strArray = new string[100];
            char[] charArray = new char[1];

            charArray[0] = ' ';
            
            //remove the command from the line read in
            strPassLine = strPassLine.Substring(2, strPassLine.Length - 2);

            strArray = strPassLine.Split(charArray); //split the passed line

            if (strPassLine[0] == 'S') //check for scope
            {
                strKey = strArray[1] + strArray[3];
            }
            else if (strPassLine[0] == 'L') //check for lexeme assume current scope
            {
                
                strKey = scopeTracker.Current() + strArray[1];
            }
            else
                strKey = "ERROR_BAD_INPUT";

            return strKey;

        }

        /* The method returns the value of the desired table entry. for non-array entries.  You should
         * pass the key of the entry you desire to get the value of. You can check other scopes by using
         * the hashkey(string, string) method.
         */
        /* Variable             Type                Purpose
         * id                   string              it hold the key to be referenced
         * idEntry              IDENTIFIER          it hold the returned identier
         */
        public string get(string id)
        {
            IDENTIFIER idEntry = new IDENTIFIER((IDENTIFIER)hashSymbolTable[id]);
            
            return idEntry.Value;         
        }

        /* This method returns the value of the desired index of the desired table entry, for array entries. You should
         * pass the key of the entry you desire to get the value of, and the index (1 indexing for the array)
         * (index 0 is the size of the array do not change the size of the array). You can check other scopes by using
         * the hashkey(string, string) method.
         */
        /* Variable             Type                Purpose
         * charArray            char[]              it is used as the parameter of string split method
         * id                   string              it hold the key to be referenced
         * idEntry              IDENTIFIER          it hold the returned identier
         * value                int                 it holds the index of the desired element in the array
         * strArray             string[]            it is used to hold the substring generated by string split
         */
        public string get(string id, int value)
        {
            IDENTIFIER idEntry = new IDENTIFIER((IDENTIFIER)hashSymbolTable[id]);

            char[] charArray = new char[1];

            charArray[0] = ' ';

            string[] strArray = new string[100];

            strArray = idEntry.Value.Split(charArray);

            try
            {
                return strArray[value];
            }
            catch (IndexOutOfRangeException)
            {
                return "NOT_FOUND";
            }
        }

        /* This method will let you change the token or value of the desired table entry.
         * if you do not wish to change the the token or the value for the string of token or
         * value use the string "KEEP".
         */

        /* Variable             Type                Purpose
         * e                    IndexOutOfRangeExpcetions It's an expcetion
         * KEEP                 string              it is used by put methods and by callers of the put method
         *                                          it tells the put methods if you want to keep token or value
         * idTemp               IDENTIFIER          It hold the identifier being refenced
         * strId                string              it hold the key to be referenced
         * strToken             string              it holds the new Token type
         * strValue             string              it holds the new Value type
         */

        public string KEEP = "KEEP";
                
        public bool put(string strId, string strToken, string strValue)
        { 
            IDENTIFIER idTemp = (IDENTIFIER)hashSymbolTable[strId];

            if (idTemp == null || idTemp.Scope == "NULL" && idTemp.Lexeme == "NULL")
            {
                IndexOutOfRangeException e = new IndexOutOfRangeException();

                throw e;  
            }

            if (strToken != KEEP)
            {
                idTemp.Token = strToken;
                idTemp.CheckForArr();
            }

            if (strValue != KEEP)
            {
                idTemp.Value = strValue;
                idTemp.CheckForArr();
            }

            hashSymbolTable[strId] = idTemp;

            return true;
        }

        /* This method will let you change the token, or array value value of the desired table entry.
         * if you do not wish to change the the token or the value for the string of token or
         * value use the string "KEEP".
         */

        /* for variable destripts see other put method comments
         * Variable             Type                Purpose
         * intValue             int                 stores index to be change in array of desired identifier
         */
        public bool put(string strId, string strToken, int intValue, string strValue)
        {
            IDENTIFIER idTemp = (IDENTIFIER)hashSymbolTable[strId];

            if (idTemp == null || idTemp.Scope == "NULL" && idTemp.Lexeme == "NULL")
            {
                IndexOutOfRangeException e = new IndexOutOfRangeException();

                throw e;                
            }

            if (strToken != KEEP)
            {
                idTemp.Token = strToken;
                idTemp.CheckForArr();
            }

            if (strValue != KEEP)
            {
                string[] strArray = new string[100];
                char[] charArray = new char[1];

                charArray[0] = ' ';

                strArray = idTemp.Value.Split(charArray);

                try
                {
                    strArray[intValue] = strValue;
                }
                catch (IndexOutOfRangeException)
                {
                    return false;
                }

                idTemp.Value = "";

                for (int intI = 0; intI < strArray.Length; intI++)
                {
                    idTemp.Value += strArray[intI] + " ";
                }

                //idTemp.Value = idTemp.Value.Substring(1, idTemp.Value.Length - 1);
            }

            hashSymbolTable[strId] = idTemp;

            return true;

        }

        /* This method will insert the desired lexeme into the table.  The lexeme needs to be stored
         * in an IDENTIFIER, and you should generated the key using hashkey(string) or hashkey(string, string)
         */

        /* Variable             Type                Purpose
         * idLexeme             IDENTIFIER          it is the identifier to be stored in table
         * strKey               string              it is the key
         */
        public void Insert(IDENTIFIER idLexeme, string strKey)
        { hashSymbolTable[strKey] = idLexeme; }

        /* This method will check to see if a desired entry is in the table.
         * Use the hashkey methods to generate the key
         */

        /* Variable             Type                Purpose
         * strLexeme            string              holds the key to be checked for 
         */
        public bool contains(string strLexeme)
        { return hashSymbolTable.Contains(strLexeme); }

        // This method dumps the contents of the hashtable to the console

        /* Variable             Type                Purpose
         * charArray            char[]              is used a peramiter for string split method
         * idOut                IDENTIFIER          holds the Identifier to be printed to the console
         * intCnt               int                 it is a counter
         * strArray             string[]            holds the substrings generated by string split method
         * strToConsole         string              store strings to be printed to the screen
         */
        public void Dump()
        {
            Console.WriteLine("\n\n\nSymbol Table\n");

            IDENTIFIER idOut;
            string strToConsole = "";
            string[] strArray = new string[1];
            char[] charArray = new char[1];

            charArray[0] = ' ';

            Console.Write("{0,-32} {1,-32} {2,-32} {3,-8} {4,-32}\n", "Key", "Scope", "Lexeme", "Token", "Stored Value");

            foreach (string strKey in hashSymbolTable.Keys)
            {
                idOut = (IDENTIFIER) hashSymbolTable[strKey];

                Console.Write("{0, -32} ", strKey);                

                Console.Write("{0,-32} ", idOut.Scope);                

                Console.Write("{0,-32} ", idOut.Lexeme);
                
                strToConsole = idOut.Token;

                Console.Write("{0,-8} ", idOut.Token);

                strArray = idOut.Value.Split(charArray);
 
                int intCnt = 0;

                foreach (string strItr in strArray)
                {
                    if (intCnt == 0)
                    {
                        Console.Write(strItr + "\n");
                        intCnt++;
                    }
                    else
                        Console.Write("{0,-107} {1}\n", " ", strItr);                    
                }
             }

                Console.Write("\n");
                        
            return;
        }
    }

    /* Variable             Type                Purpose
     * Lexeme               string              getter/setter
     * Scope                string              getter/setter
     * strLexeme            string              stores the lexeme
     * strScope             string              stores the scope
     * strToken             string              stores the token
     * strValue             string              stores the Vaule(s)
     * Token                string              getter/setter
     * Value                string              getter/setter
     */
    public class IDENTIFIER
    {
        //default constructor
        public IDENTIFIER()
        {
            Lexeme = Scope = Token = Value = "NULL";
        }

        //copy constructor
        /* Variable             Type                Purpose
         * idOrg                IDENTIFIER          it is the identifier to be copied
         */
        public IDENTIFIER(IDENTIFIER idOrg)
        {
            try
            {
                Lexeme = idOrg.Lexeme;
                Scope = idOrg.Scope;
                Token = idOrg.Token;
                Value = idOrg.Value;
            }
            catch (NullReferenceException)
            {
                Lexeme = Scope = Token = Value = "NULL";
            }

        }

        //intialize constructor
        /* Variable             Type                Purpose
         * charArray            char[]              is used as paramiter for string split method
         * intI                 int                 Itorator (two different locations)
         * strArray             string[]            stores substrings generated by string split method
         * strPassLine          string              store the string read in from line
         * 
         */
        public IDENTIFIER(string strPassLine)
        {
            string[] strArray = new string[100];
            char[] charArray = new char[1];

            charArray[0] = ' ';

            //remove the command from the line read in
            strPassLine = strPassLine.Substring(2, strPassLine.Length - 2);

            strArray = strPassLine.Split(charArray);
            
            Scope = strArray[1];

            Lexeme = strArray[3];

            if (strArray.Length > 5) //check for T or V
            {
                if (strArray[4] == "T") //verify T
                {
                    Token = strArray[5];

                    if (strArray.Length > 6) // check for V
                    {
                        Value = "";     //set value with provided value or values

                        for (int intI = 7; intI < strArray.Length; intI++)
                            Value += " " + strArray[intI];

                        Value = Value.Substring(1, Value.Length - 1);

                        //check that all arrays have intial values for indexes

                        CheckForArr();
                    }
                    else // !V
                    { Value = "NULL"; }
                }
                else // !T -> set Value
                {
                    Token = "NULL";

                    if (strArray.Length > 5) //verify that values are provided
                    {
                        Value = "";

                        for (int intI = 5; intI < strArray.Length; intI++)
                            Value += " " + strArray[intI];

                        Value = Value.Substring(1, Value.Length - 1);
                    }
                    else //no values provided
                        Value = "NULL";

                }
            }
            else // no values or tokens provided
            {
                Token = "NULL";
                Value = "NULL";
            }
        }

        /* This method will check to see if entry is an array. if it is it constructs the intial values
         * It is intended to be used by the default constructor, but it might be useful in other situations
         */

        /* Variable             Type                Purpose 
         * charArray            char[]              is used as paramiter for string split method
         * intI                 int                 Itorator
         * intSize              int                 stores the size of the array
         * strArray             string[]            stores substrings generated by string split method
         * strTemp              string[]            store the substrings to be concatinated
         */
        public void CheckForArr()
        {
            if (Token == "FltArr" || Token == "IntArr")
            {
                string[] strArray = new string[100];
                char[] charArray = new char[1];

                charArray[0] = ' ';

                strArray = Value.Split(charArray);

                int intSize = Int32.Parse(strArray[0]);

                if (strArray.Length + 2 != intSize)
                { 
                    string[] strTemp = new string[intSize+1];
                    int intI = 0;
                    
                    //copy intial values
                    for (intI = 0; intI < strArray.Length; intI++)
                        strTemp[intI] = strArray[intI];

                    //set remaining values of array to NULL
                    for (; intI < strTemp.Length; intI++)
                        strTemp[intI] = "NULL";

                    //store temp array in value as a space seperated string

                    Value = "";

                    for (intI = 0; intI < strTemp.Length; intI++)
                        Value += strTemp[intI] + " ";
                }                
            }
        }

        private string strLexeme;
        public string Lexeme
        {
            get { return strLexeme; }
            set { strLexeme = value; }
        }

        private string strScope;
        public string Scope
        {
            get { return strScope; }
            set { strScope = value; }
        }

        private string strToken;
        public string Token
        {
            get { return strToken; }
            set { strToken = value; }
        }

        private string strValue;
        public string Value
        {
            get { return strValue; }
            set { strValue = value; }
        }
        
    }

    /* Variable             Type                Purpose
     * intTop               int                 points to the top of the stack
     * NO_SCOPE             string              no scope sentinal
     * strScope             string[]            it is the stack
     */
    public class SCOPE
    {
        public string NO_SCOPE = "NO_SCOPE";

        private string[] strScope = new string[1000];
        private int intTop = -1;

        // Ends the scope
        public bool End() //remove scope by removing access to current scope
        {
            if (intTop > -1)
            {
                intTop--;

                return true; // if remove successful return true
            }

            return false; //if remove fails return false
        }

        // Begins the scope. strNewScope is the name of the scope
        public bool Begin(string strNewScope)
        {
            if (intTop < 998)
            {
                intTop++;
                
                strScope[intTop] = strNewScope;

                return true;
            }

            return false;
        }

        // Returns the name of the current scope
        public string Current()
        {
            try
            {
                return strScope[intTop];
            }
            catch (IndexOutOfRangeException)
            {
                return NO_SCOPE;
            }
        }
        
        //The method will return the parent scope of the desired scope if it is in the scope tracker 

        /* Variable             Type                Purpose 
         * boolNtFd             bool                stores decision for Parent Found/Not_Found
         * intI                 int                 stack itorator
         * strCurrent           string              Current scope, for whose parent you wish to find
         */
        public string Parent(string strCurrent)
        {
            int intI = intTop;
            bool boolNtFd = true;

            for (; intI > -1 && boolNtFd; intI--)
                if (strCurrent == strScope[intI])
                    boolNtFd = false;

            try
            {
                return strScope[intI];
            }
            catch (IndexOutOfRangeException)
            {
                return NO_SCOPE;
            }
        }

    }
}

>>>type Program.cs
/* Programmer:          Timothy Beckett (Coder) */
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using SymbolTable;


namespace symbolexample
{
    class Program
    {
        static classSymbolTable objSymbolTable = new classSymbolTable();

        static void Main(string[] args)
        {
            try
            {
                DebugSymbolTable(args[0]);
            }
            catch (IndexOutOfRangeException exceptionArgsIsEmpty)
            {
                Console.Write(exceptionArgsIsEmpty.ToString());
            }

            objSymbolTable.Dump();
                        
        }
        
        /* Variable             Type            Purpose
         * boolChoose           bool            used in the switch under case P
         *                                      used to determine which put method to choose
         * boolPF               bool            used in the switch under case P
         *                                      It determines the success or failure ot the put method
         * charArray            char[]          It used in several places to as the value of the split operatoin of strings
         * FileStream           StreamReader    for reading data from the file
         * idEntry              IDENTIFIER      Used in the switch under case I
         *                                      It stores the Lexeme to be stored in the hash table
         * intValue             int             used in the switch under case G
         *                                      it is used to store the index number of an array that is to be retreived
         * strArray             string[]        it is used through out the method to store substrings derived from a split
         *                                      operation.
         * strEntry             string          it is used through out the method to store the hash key of interest
         * strRetVal            string          it is used in the switch under case G
         *                                      it is used to store the returned value
         * strScope             string          it id used through out the switch statement to store the scope of interest
         * strToken             string          it is used in the switch under case P
         *                                      it store the token to be put into the desired IDENTIFIER
         * strValue             string          it is used in the switch under case P
         *                                      it stores the value to be put into the desired IDENTIFIER
         */
        static void DebugSymbolTable(string strFilename)
        {
            
            StreamReader FileStream; //used for reading the file
            string strEntry, //used for querries of the table
                   strScope, //used for keep track of scope
                   strRetVal; //used to catch the return value of get operation
            string[] strArray = new string[1]; //used for string splitting
            char[] charArray = new char[1]; //used for string splitting
            int intValue = 0; //used for store value for get operation
            IDENTIFIER idEntry = new IDENTIFIER();  //used for inserting item to table
            string strToken = "", //used in the put operation
                   strValue = ""; //used in the put operation
            bool boolChoose = false, //used in the put operation to choose put method
                 boolPF = false; //used in the put operation to determine sucess or failure of put method

            charArray[0] = ' '; //space delimited strings

            try
            {
                FileStream = new StreamReader(strFilename);
            }
            catch (FileNotFoundException exceptionFileNotFound)
            {
                Console.WriteLine(exceptionFileNotFound.Message + "\nInput File Not Found");
                return;
            }

            string strReadLine;

            strReadLine = FileStream.ReadLine();

                     
            while (strReadLine != null)
            {
                Console.Write("\n" + strReadLine + "\n");

                //determine action to be preformed
                switch (strReadLine[0])
                {
                    case 'B':
                        //begin a scope
                        objSymbolTable.scopeTracker.Begin(strReadLine.Substring(2, strReadLine.Length-2));
                        
                        break; //end of case 'B'
                    
                    case 'C':
                        //check current scope for desired entry
                        //it must be provided with a scope as stated in class
                        strEntry = objSymbolTable.hashKey(strReadLine);



                        if(objSymbolTable.contains(strEntry))
                            Console.Write("Found entry " + strEntry + "\n");
                        else
                            Console.Write("Did not find entry " + strEntry +"\n");
                         
                        break; //end of case 'C'
                    
                    case 'D':
                        //dump the hash table to the screen
                        objSymbolTable.Dump();
            
                        break;
                    
                    case 'E': 
                        //end the scope
                        objSymbolTable.scopeTracker.End();
                        
                        break; //end of case 'E'
                    
                    case 'G':

                        //get the value from the hash table
                        
                        strEntry = objSymbolTable.hashKey(strReadLine);  //get hash table key

                        //determine if there is a given value in the string

                        strArray = strReadLine.Split(charArray);

                        if (strArray.Length > 3) //check for value
                        {
                            boolChoose = true;

                            if(strArray.Length > 8) //get value
                            { intValue = Int32.Parse(strArray[8]); }
                            else if (strArray.Length > 6 && strArray[5] == "V")
                            { intValue = Int32.Parse(strArray[6]); }
                            else if (strArray[3] == "V")
                            { intValue = Int32.Parse(strArray[4]); }
                            else
                            { boolChoose = false; }

                            strRetVal = objSymbolTable.get(strEntry, intValue);

                            strScope = objSymbolTable.scopeTracker.Current();

                            while (strScope != objSymbolTable.scopeTracker.NO_SCOPE)
                            {
                                if (boolChoose)
                                    strRetVal = objSymbolTable.get(strEntry, intValue);
                                else
                                    strRetVal = objSymbolTable.get(strEntry);

                                //if the search fails to find the item in the table
                                //then search the parent scopes of the current scope

                                strScope = objSymbolTable.scopeTracker.Parent(strScope);

                                strEntry = objSymbolTable.hashKey(strReadLine, strScope); //rehash
                            }
                        }
                        else // no scope  or no value provided
                        {
                            strRetVal = objSymbolTable.get(strEntry);

                            strScope = objSymbolTable.scopeTracker.Current();

                            while (strScope != objSymbolTable.scopeTracker.NO_SCOPE)
                            {
                                //if the search fails to find the item in the table
                                //then search the parent scopes of the current scope

                                strEntry = objSymbolTable.hashKey(strReadLine, strScope); //rehash

                                strScope = objSymbolTable.scopeTracker.Parent(strScope);

                                strRetVal = objSymbolTable.get(strEntry);

                            }
                        }

                        Console.Write("The returned value is " + strRetVal + "\n");

                        break;  //end of case 'G'
                        
                    case 'I':
                        //insert new item to the table
                        strEntry = objSymbolTable.hashKey(strReadLine); //get hash table key

                        idEntry = new IDENTIFIER(strReadLine); //set up lexeme

                        if (!objSymbolTable.contains(strEntry)) //check if lexeme is in table
                        {
                            objSymbolTable.Insert(idEntry, strEntry); //if unique insert
                            Console.Write("Added to table: " + idEntry.Scope + " "
                                                             + idEntry.Lexeme + " "
                                                             + idEntry.Token + " "
                                                             + idEntry.Value + "\n");
                        }
                        else
                            Console.Write("The Lexeme "+ strEntry +" is already in the table\n");

                        break; //end of case 'I'
                    
                    case 'P':
                        // change the value of an table item

                        strArray = strReadLine.Split(charArray); //split the sub strings

                        strEntry = objSymbolTable.hashKey(strReadLine); //get first hash key

                        strScope = objSymbolTable.scopeTracker.Current(); //get the current scope

                        if (strArray.Length > 8)
                        {// provided scope
                            if (strArray.Length > 9)
                            {// two values
                                strToken = strArray[6];
                                intValue = Int32.Parse(strArray[8]);
                                strValue = strArray[9];
                                boolChoose = false;
                            }
                            else
                            {// one value
                                boolChoose = true;
                                strValue = strArray[8];
                                strToken = strArray[6];
                            }                            
                        }
                        //no scope provided for the following cases
                        else if (strArray.Length > 6)
                        {// Provided token and value

                            if (strArray.Length > 7)
                            {// two values
                                strToken = strArray[4];
                                intValue = Int32.Parse(strArray[6]);
                                strValue = strArray[7];
                                boolChoose = false;
                            }
                            else
                            {// one value
                                boolChoose = true;
                                strValue = strArray[6];
                                strToken = strArray[4];
                            }
                        }
                        else
                        {   
                            if (strArray[3] == "T")
                            { //provided a token change

                                boolChoose = false;
                                strValue = objSymbolTable.KEEP;
                                strToken = strArray[4];                                
                            }
                            else
                            { //provided a value change
                                if (strArray.Length > 5)
                                //two values provided
                                {
                                    intValue = Int32.Parse(strArray[4]);
                                    boolChoose = false;
                                    strToken = objSymbolTable.KEEP;
                                    strValue = strArray[5];
                                }
                                else
                                { // one value provided
                                    boolChoose = true;
                                    strValue = strArray[4];
                                    strToken = objSymbolTable.KEEP;
                                }
                            }
                        }

                        boolPF = false;

                        if(boolChoose)
                        {//one value put
                            
                            while (!boolPF && strScope != objSymbolTable.scopeTracker.NO_SCOPE)
                            {
                                try
                                {
                                    boolPF = objSymbolTable.put(strEntry, strToken, strValue);
                                }
                                catch (IndexOutOfRangeException)
                                { 
                                
                                }
                                
                                strScope = objSymbolTable.scopeTracker.Parent(strScope);

                                strEntry = objSymbolTable.hashKey(strReadLine, strScope);
                            }
                        }
                        else
                        {//two value put
                             while (!boolPF && strScope != objSymbolTable.scopeTracker.NO_SCOPE)
                             {
                                 try
                                 {
                                     boolPF = objSymbolTable.put(strEntry, strToken, intValue, strValue);
                                 }
                                 catch (IndexOutOfRangeException)
                                 { 
                                 
                                 }
                                 
                                 strScope = objSymbolTable.scopeTracker.Parent(strScope);

                                 strEntry = objSymbolTable.hashKey(strReadLine, strScope);
                             }
                        }

                        if (boolPF)
                            Console.Write("Operation Sucessful\n");
                        else
                            Console.Write("Operation Failed\n");

                        break; //end of case 'P'
                    
                };

               strReadLine = FileStream.ReadLine(); //get next command from the file
                
            }
            FileStream.Close();
        }
    }

}

>>>symbolexample.exe symbol_debug.txt

B main1

C S main1 L A
Did not find entry main1A

I S main1 L A T IntId
Added to table: main1 A IntId NULL

C S main1 L B
Did not find entry main1B

I S main1 L B T IntArr V 12
Added to table: main1 B IntArr 12 NULL NULL NULL NULL NULL NULL NULL NULL NULL NULL NULL NULL 

C S main1 L C
Did not find entry main1C

I S main1 L A T IntId
The Lexeme main1A is already in the table

D



Symbol Table

Key                              Scope                            Lexeme                           Token    Stored Value                    
main1B                           main1                            B                                IntArr   12
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            
main1A                           main1                            A                                IntId    NULL


B main2

C S main2 L X
Did not find entry main2X

I S main2 L X T IntId
Added to table: main2 X IntId NULL

C S main2 L C
Did not find entry main2C

I S main2 L A T IntId
Added to table: main2 A IntId NULL

P L A V 4
Operation Sucessful

P L C V 5
Operation Failed

D



Symbol Table

Key                              Scope                            Lexeme                           Token    Stored Value                    
main1B                           main1                            B                                IntArr   12
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            
main2X                           main2                            X                                IntId    NULL
main2A                           main2                            A                                IntId    4
main1A                           main1                            A                                IntId    NULL


G L A
The returned value is NULL

G L C
The returned value is NULL

P L X V 9
Operation Sucessful

G L X
The returned value is NULL

P L B V 3 9
Operation Sucessful

G L C
The returned value is NULL

P S main1 L C V 5
Operation Failed

G S main1 L C
The returned value is NULL

G S main1 L C T
The returned value is NULL

G S main1 L C V
The returned value is NULL

G L B V 20
The returned value is NOT_FOUND

G L B V -1
The returned value is NOT_FOUND

D



Symbol Table

Key                              Scope                            Lexeme                           Token    Stored Value                    
main1B                           main1                            B                                IntArr   12
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            9
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            
                                                                                                            
main2X                           main2                            X                                IntId    9
main2A                           main2                            A                                IntId    4
main1A                           main1                            A                                IntId    NULL


E

B main3

C S main3 L A
Did not find entry main3A

I S main3 L A T IntId
Added to table: main3 A IntId NULL

C S main3 L Y
Did not find entry main3Y

I S main3 L Y T IntId
Added to table: main3 Y IntId NULL

P L A V 7
Operation Sucessful

P L Y V 9
Operation Sucessful

G L A
The returned value is NULL

G L Y
The returned value is NULL

G L X
The returned value is NULL

P L C V 25
Operation Failed

G L B V 3
The returned value is 9

E

E



Symbol Table

Key                              Scope                            Lexeme                           Token    Stored Value                    
main3Y                           main3                            Y                                IntId    9
main1B                           main1                            B                                IntArr   12
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            9
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            NULL
                                                                                                            
                                                                                                            
main2X                           main2                            X                                IntId    9
main3A                           main3                            A                                IntId    7
main2A                           main2                            A                                IntId    4
main1A                           main1                            A                                IntId    NULL


>>>exit

