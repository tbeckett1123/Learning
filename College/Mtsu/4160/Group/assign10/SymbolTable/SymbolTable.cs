/* Programmer:          Timothy Beckett (Coder) */
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;

namespace SymbolTable
{
    /* Variable             Type                Purpose
     * hashSymbolTable      Hashtable           it is the hashtable
     * scopeTracker         SCOPE               it keep track of the current scope
     */
    public class classSymbolTable
    {
        public Hashtable hashSymbolTable = new Hashtable();
        public SCOPE scopeTracker = new SCOPE();

        
        /* The method will create a hash key given from the text read from the line from the file and the provided scope
         * it will force.
         */
        /* Variable             Type                Purpose
         * charArray            char[]              it is used as the parameter of string split method
         * strForceScope        string              it hold the scope to be used in the key
         * strArray             string[]            it is used to hold the substring generated by string split
         * strKey               string              it store the key that is generated
         * strPassLine          sting               it is the string read in from the file
         */
        public string hashKey(string strPassLine, string strForceScope)
        {
            string strKey = "";
            string[] strArray = new string[100];
            char[] charArray = new char[1];

            charArray[0] = ' ';

            //remove the command from the line read in
            strPassLine = strPassLine.Substring(2, strPassLine.Length - 2);

            strArray = strPassLine.Split(charArray); //split the passed line

            if (strArray[0] == "S")
            {
                strKey = strForceScope + strArray[3];
            }
            else
            {
                strKey = strForceScope + strArray[1];
            }

            return strKey;

        }

        /* creates a hash key. this is ment to be used the first time you create a hash key. 
         * it creates a key from the line read in from the file. if no scope is provided then the current
         * scope is used.
         */
        /* Variable             Type                Purpose
         * charArray            char[]              it is used as the parameter of string split method
         * strArray             string[]            it is used to hold the substring generated by string split
         * strKey               string              it store the key that is generated
         * strPassLine          string              it is the string read in from the file
         */
        public string hashKey(string strPassLine)
        {
            string strKey = "";
            string[] strArray = new string[100];
            char[] charArray = new char[1];

            charArray[0] = ' ';
            
            //remove the command from the line read in
            strPassLine = strPassLine.Substring(2, strPassLine.Length - 2);

            strArray = strPassLine.Split(charArray); //split the passed line

            if (strPassLine[0] == 'S') //check for scope
            {
                strKey = strArray[1] + strArray[3];
            }
            else if (strPassLine[0] == 'L') //check for lexeme assume current scope
            {
                
                strKey = scopeTracker.Current() + strArray[1];
            }
            else
                strKey = "ERROR_BAD_INPUT";

            return strKey;

        }

        /* The method returns the value of the desired table entry. for non-array entries.  You should
         * pass the key of the entry you desire to get the value of. You can check other scopes by using
         * the hashkey(string, string) method.
         */
        /* Variable             Type                Purpose
         * id                   string              it hold the key to be referenced
         * idEntry              IDENTIFIER          it hold the returned identier
         */
        public string get(string id)
        {
            IndexOutOfRangeException e = new IndexOutOfRangeException();

            IDENTIFIER idEntry = new IDENTIFIER((IDENTIFIER)hashSymbolTable[id]);

            if (idEntry.Scope == "NULL")
                throw (e);

            return idEntry.Value;         
        }

        /* This method returns the value of the desired index of the desired table entry, for array entries. You should
         * pass the key of the entry you desire to get the value of, and the index (1 indexing for the array)
         * (index 0 is the size of the array do not change the size of the array). You can check other scopes by using
         * the hashkey(string, string) method.
         */
        /* Variable             Type                Purpose
         * charArray            char[]              it is used as the parameter of string split method
         * id                   string              it hold the key to be referenced
         * idEntry              IDENTIFIER          it hold the returned identier
         * value                int                 it holds the index of the desired element in the array
         * strArray             string[]            it is used to hold the substring generated by string split
         */
        public string get(string id, int value)
        {
            IndexOutOfRangeException e = new IndexOutOfRangeException();

            IDENTIFIER idEntry = new IDENTIFIER((IDENTIFIER)hashSymbolTable[id]);

            if (idEntry.Scope == "NULL")
                throw (e);

            char[] charArray = new char[1];

            charArray[0] = ' ';

            string[] strArray = new string[100];

            strArray = idEntry.Value.Split(charArray);

            try
            {
                return strArray[value];
            }
            catch (IndexOutOfRangeException)
            {
                return "NOT_FOUND";
            }
        }

        /* This method will let you change the token or value of the desired table entry.
         * if you do not wish to change the the token or the value for the string of token or
         * value use the string "KEEP".
         */

        /* Variable             Type                Purpose
         * e                    IndexOutOfRangeExpcetions It's an expcetion
         * KEEP                 string              it is used by put methods and by callers of the put method
         *                                          it tells the put methods if you want to keep token or value
         * idTemp               IDENTIFIER          It hold the identifier being refenced
         * strId                string              it hold the key to be referenced
         * strToken             string              it holds the new Token type
         * strValue             string              it holds the new Value type
         */

        public string KEEP = "KEEP";
                
        public bool put(string strId, string strToken, string strValue)
        { 
            IDENTIFIER idTemp = (IDENTIFIER)hashSymbolTable[strId];

            if (idTemp == null || idTemp.Scope == "NULL" && idTemp.Lexeme == "NULL")
            {
                IndexOutOfRangeException e = new IndexOutOfRangeException();

                throw e;  
            }

            if (strToken != KEEP)
            {
                idTemp.Token = strToken;
                idTemp.CheckForArr();
            }

            if (strValue != KEEP)
            {
                idTemp.Value = strValue;
                idTemp.CheckForArr();
            }

            hashSymbolTable[strId] = idTemp;

            return true;
        }

        /* This method will let you change the token, or array value value of the desired table entry.
         * if you do not wish to change the the token or the value for the string of token or
         * value use the string "KEEP".
         */

        /* for variable destripts see other put method comments
         * Variable             Type                Purpose
         * intValue             int                 stores index to be change in array of desired identifier
         */
        public bool put(string strId, string strToken, int intValue, string strValue)
        {
            IDENTIFIER idTemp = (IDENTIFIER)hashSymbolTable[strId];

            if (idTemp == null || idTemp.Scope == "NULL" && idTemp.Lexeme == "NULL")
            {
                IndexOutOfRangeException e = new IndexOutOfRangeException();

                throw e;                
            }

            if (strToken != KEEP)
            {
                idTemp.Token = strToken;
                idTemp.CheckForArr();
            }

            if (strValue != KEEP)
            {
                string[] strArray = new string[100];
                char[] charArray = new char[1];

                charArray[0] = ' ';

                strArray = idTemp.Value.Split(charArray);

                try
                {
                    strArray[intValue] = strValue;
                }
                catch (IndexOutOfRangeException)
                {
                    return false;
                }

                idTemp.Value = "";

                for (int intI = 0; intI < strArray.Length; intI++)
                {
                    idTemp.Value += strArray[intI] + " ";
                }

                //idTemp.Value = idTemp.Value.Substring(1, idTemp.Value.Length - 1);
            }

            hashSymbolTable[strId] = idTemp;

            return true;

        }

        /* This method will insert the desired lexeme into the table.  The lexeme needs to be stored
         * in an IDENTIFIER, and you should generated the key using hashkey(string) or hashkey(string, string)
         */

        /* Variable             Type                Purpose
         * idLexeme             IDENTIFIER          it is the identifier to be stored in table
         * strKey               string              it is the key
         */
        public void Insert(IDENTIFIER idLexeme, string strKey)
        { hashSymbolTable[strKey] = idLexeme; }

        /* This method will check to see if a desired entry is in the table.
         * Use the hashkey methods to generate the key
         */

        /* Variable             Type                Purpose
         * strLexeme            string              holds the key to be checked for 
         */
        public bool contains(string strLexeme)
        { return hashSymbolTable.Contains(strLexeme); }

        // This method dumps the contents of the hashtable to the console

        /* Variable             Type                Purpose
         * charArray            char[]              is used a peramiter for string split method
         * idOut                IDENTIFIER          holds the Identifier to be printed to the console
         * intCnt               int                 it is a counter
         * strArray             string[]            holds the substrings generated by string split method
         * strToConsole         string              store strings to be printed to the screen
         */
        public void Dump()
        {
            Console.WriteLine("\n\n\nSymbol Table\n");

            IDENTIFIER idOut;
            string strToConsole = "";
            string[] strArray = new string[1];
            char[] charArray = new char[1];

            charArray[0] = ' ';

            Console.Write("{0,-32} {1,-32} {2,-32} {3,-8} {4,-32}\n", "Key", "Scope", "Lexeme", "Token", "Stored Value");

            foreach (string strKey in hashSymbolTable.Keys)
            {
                idOut = (IDENTIFIER) hashSymbolTable[strKey];

                Console.Write("{0, -32} ", strKey);                

                Console.Write("{0,-32} ", idOut.Scope);                

                Console.Write("{0,-32} ", idOut.Lexeme);
                
                strToConsole = idOut.Token;

                Console.Write("{0,-8} ", idOut.Token);

                strArray = idOut.Value.Split(charArray);
 
                int intCnt = 0;

                foreach (string strItr in strArray)
                {
                    if (intCnt == 0)
                    {
                        Console.Write(strItr + "\n");
                        intCnt++;
                    }
                    else
                        Console.Write("{0,-107} {1}\n", " ", strItr);                    
                }
             }

                Console.Write("\n");
                        
            return;
        }
    }

    /* Variable             Type                Purpose
     * Lexeme               string              getter/setter
     * Scope                string              getter/setter
     * strLexeme            string              stores the lexeme
     * strScope             string              stores the scope
     * strToken             string              stores the token
     * strValue             string              stores the Vaule(s)
     * Token                string              getter/setter
     * Value                string              getter/setter
     */
    public class IDENTIFIER
    {
        //default constructor
        public IDENTIFIER()
        {
            Lexeme = Scope = Token = Value = "NULL";
        }

        //copy constructor
        /* Variable             Type                Purpose
         * idOrg                IDENTIFIER          it is the identifier to be copied
         */
        public IDENTIFIER(IDENTIFIER idOrg)
        {
            try
            {
                Lexeme = idOrg.Lexeme;
                Scope = idOrg.Scope;
                Token = idOrg.Token;
                Value = idOrg.Value;
            }
            catch (NullReferenceException)
            {
                Lexeme = Scope = Token = Value = "NULL";
            }

        }

        //intialize constructor
        /* Variable             Type                Purpose
         * charArray            char[]              is used as paramiter for string split method
         * intI                 int                 Itorator (two different locations)
         * strArray             string[]            stores substrings generated by string split method
         * strPassLine          string              store the string read in from line
         * 
         */
        public IDENTIFIER(string strPassLine)
        {
            string[] strArray = new string[100];
            char[] charArray = new char[1];

            charArray[0] = ' ';

            //remove the command from the line read in
            strPassLine = strPassLine.Substring(2, strPassLine.Length - 2);

            strArray = strPassLine.Split(charArray);
            
            Scope = strArray[1];

            Lexeme = strArray[3];

            if (strArray.Length > 5) //check for T or V
            {
                if (strArray[4] == "T") //verify T
                {
                    Token = strArray[5];

                    if (strArray.Length > 6) // check for V
                    {
                        Value = "";     //set value with provided value or values

                        for (int intI = 7; intI < strArray.Length; intI++)
                            Value += " " + strArray[intI];

                        Value = Value.Substring(1, Value.Length - 1);

                        //check that all arrays have intial values for indexes

                        CheckForArr();
                    }
                    else // !V
                    { Value = "NULL"; }
                }
                else // !T -> set Value
                {
                    Token = "NULL";

                    if (strArray.Length > 5) //verify that values are provided
                    {
                        Value = "";

                        for (int intI = 5; intI < strArray.Length; intI++)
                            Value += " " + strArray[intI];

                        Value = Value.Substring(1, Value.Length - 1);
                    }
                    else //no values provided
                        Value = "NULL";

                }
            }
            else // no values or tokens provided
            {
                Token = "NULL";
                Value = "NULL";
            }
        }

        /* This method will check to see if entry is an array. if it is it constructs the intial values
         * It is intended to be used by the default constructor, but it might be useful in other situations
         */

        /* Variable             Type                Purpose 
         * charArray            char[]              is used as paramiter for string split method
         * intI                 int                 Itorator
         * intSize              int                 stores the size of the array
         * strArray             string[]            stores substrings generated by string split method
         * strTemp              string[]            store the substrings to be concatinated
         */
        public void CheckForArr()
        {
            if (Token == "FltArr" || Token == "IntArr")
            {
                string[] strArray = new string[100];
                char[] charArray = new char[1];

                charArray[0] = ' ';

                strArray = Value.Split(charArray);

                int intSize = Int32.Parse(strArray[0]);

                if (strArray.Length + 2 != intSize)
                { 
                    string[] strTemp = new string[intSize+1];
                    int intI = 0;
                    
                    //copy intial values
                    for (intI = 0; intI < strArray.Length; intI++)
                        strTemp[intI] = strArray[intI];

                    //set remaining values of array to NULL
                    for (; intI < strTemp.Length; intI++)
                        strTemp[intI] = "NULL";

                    //store temp array in value as a space seperated string

                    Value = "";

                    for (intI = 0; intI < strTemp.Length; intI++)
                        Value += strTemp[intI] + " ";
                }                
            }
        }

        private string strLexeme;
        public string Lexeme
        {
            get { return strLexeme; }
            set { strLexeme = value; }
        }

        private string strScope;
        public string Scope
        {
            get { return strScope; }
            set { strScope = value; }
        }

        private string strToken;
        public string Token
        {
            get { return strToken; }
            set { strToken = value; }
        }

        private string strValue;
        public string Value
        {
            get { return strValue; }
            set { strValue = value; }
        }
        
    }

    /* Variable             Type                Purpose
     * intTop               int                 points to the top of the stack
     * NO_SCOPE             string              no scope sentinal
     * strScope             string[]            it is the stack
     */
    public class SCOPE
    {
        public string NO_SCOPE = "NO_SCOPE";

        private string[] strScope = new string[1000];
        private int intTop = -1;

        // Ends the scope
        public bool End() //remove scope by removing access to current scope
        {
            if (intTop > -1)
            {
                intTop--;

                return true; // if remove successful return true
            }

            return false; //if remove fails return false
        }

        // Begins the scope. strNewScope is the name of the scope
        public bool Begin(string strNewScope)
        {
            if (intTop < 998)
            {
                intTop++;
                
                strScope[intTop] = strNewScope;

                return true;
            }

            return false;
        }

        // Returns the name of the current scope
        public string Current()
        {
            try
            {
                return strScope[intTop];
            }
            catch (IndexOutOfRangeException)
            {
                return NO_SCOPE;
            }
        }
        
        //The method will return the parent scope of the desired scope if it is in the scope tracker 

        /* Variable             Type                Purpose 
         * boolNtFd             bool                stores decision for Parent Found/Not_Found
         * intI                 int                 stack itorator
         * strCurrent           string              Current scope, for whose parent you wish to find
         */
        public string Parent(string strCurrent)
        {
            int intI = intTop;
            bool boolNtFd = true;

            for (; intI > -1 && boolNtFd; intI--)
                if (strCurrent == strScope[intI])
                    boolNtFd = false;

            try
            {
                return strScope[intI];
            }
            catch (IndexOutOfRangeException)
            {
                return NO_SCOPE;
            }
        }

    }
}
