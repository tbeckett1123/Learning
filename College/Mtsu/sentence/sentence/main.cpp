#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <ctime>

#include "grammar.h"

using namespace std;

struct IntScope
{
	int intStart;
	int intEnd;
};


// This function is supposed to split a sentence to a list of words. 
// We use array of strings to store the list of words.
int split(const string sen, string words[], const int capacity);

// Add declaration of findCategoryScope function here. This function returns
// the first and last row numbers of the rule for a category in the array
// GRAMMAR, which is defined in grammar.h
IntScope findCategoryScope(const string& THE_TOKEN);

// return a random integer in the range `[0,' `n)'
int nrand( int n );

// Add declaration of pickRuleRandomly function here. This function returns
// a random rule in the array GRAMMAR for a category by invoking functions
// findCategoryScope & nrand.
int pickRuleRandomly(const string& THE_TOKEN);

// Add declaration of isCategoryName function here. This function returns
// true if the given word is a category name, which is a word enclosed by
// a pair of angle brackets. There is no space characters within the 
// brackets.
bool isCategoryname(const string& ISCATEGORYNAME);

// Add declaration of generateSentence function here. This function generate
// a sentence/phrase for a given word. If the word is a category name, you
// need to find a rule randomly to expand it. Repeat this step for all 
// category names occuring in the rule until the generated sentence/phrase 
// has no category name. If the word is a ordinary word, just return it.
// This function are supposed to invoke split, isCategoryName, and 
// pickRuleRandomly functions.
string generateSentence(const string& THE_TOKEN);


// This function writes a sentence into a file.
void printSentence( const string fileName, const string sentence );

int main( int argc, char** argv )
{
	// initialize the seeds of random number generator
	srand( (unsigned)time(0));  

	string		sentence =""; // contain generated mission statement
	
	///////////////////////////////////////////////////////////////
	//
	// Here, you need to invoke the function generateSentence to
	// generate a mission statement by passing category name
	// MISSION_TOKEN defined in grammar.h. The mission statement
	// must be stored in the variable sentence.
	//
	///////////////////////////////////////////////////////////////

	sentence = generateSentence(MISSION_TOKEN);

	sentence = sentence.substr(0, sentence.length()-3)+"."; //getting rid of unneeded space
															//generated by grammar.h

	// write the generated mission statement into a file
	const string	outputFileName = "output.dat";
	printSentence( outputFileName, sentence );

	return 0;
}

// return a random integer in the range `[0,' `n)'
// No modification allowed for this function.
int nrand(int n)
{
	if (n <= 0 || n > RAND_MAX)
		throw domain_error("Argument to nrand is out of range");

	const int bucket_size = RAND_MAX / n;
	int r;

	do r = rand() / bucket_size;
	while (r >= n);

	return r;
}

// This function splits a sentence into a list of words. A word
// is a tring contains no space characters. We use string stream
// here, which inherits from iostream. We can use it just like
// a input or output stream after we associate it with a string.
// Parameters:
//	1. sen [in]:	the sentence to be splitted
//	2. words [out]:	the array containing the list of words
//	3. capacity [in]: the size of the array words.
// Return value:
//	The number of words in the sentence,
// No modification is allowed.
int split(const string sen, string words[], const int capacity)
{
	stringstream	ss(sen);  // associate the string stream with the string

	int		wordNums = 0;	// The number of words obtained so far

	while ( ss && (wordNums < capacity) )  //Not at the end of the string
		ss >> words[wordNums++];		  //and more space is available

	// If reach the array capacity, give a warning
	if ( wordNums == capacity )	
		cout << "Too many words in the sentence." 
			 << "Words beyond " << capacity 
			 << " in the sentence are discarded. "
			 << endl; 
	else
		wordNums --; // get rid of the last empty string
	
	return wordNums;
}

// add implementation of the function findCategoryScope here.
IntScope findCategoryScope(const string& THE_TOKEN)
{	
	IntScope IScurrentScope;
	//find category scope here.
	switch(THE_TOKEN)
	{
	
	case MISSION_TOKEN:
	
		IScurrentScope.intStart = 0;
		IScurrentScope.intEnd = 1;
	
		break;

	case OURJOB_TOKEN:
	
		IScurrentScope.intStart = 2;
		IScurrentScope.intEnd = 5;
		
		break;

	case JOB_TOKEN:
	
		IScurrentScope.intStart = 6;
		IScurrentScope.intEnd = 11;
	
		break;

	case DOGOALS_TOKEN:
	
		IScurrentScope.intStart = 12;
		IScurrentScope.intEnd = 13;
	
		break;

	case INORDERTO_TOKEN:
	
		IScurrentScope.intStart = 14;
		IScurrentScope.intEnd = 22;
	
		break;

	case BECAUSE_TOKEN:
	
		IScurrentScope.intStart = 23;
		IScurrentScope.intEnd = 30;
	
		break;

	case GOAL_TOKEN:
	
		IScurrentScope.intStart = 31;
		IScurrentScope.intEnd = 31;
		
		break;

	case ADV_TOKEN:
	
		IScurrentScope.intStart = 32;
		IScurrentScope.intEnd = 48;
		
		break;

	case VERB_TOKEN:
	
		IScurrentScope.intStart = 49;
		IScurrentScope.intEnd = 68;
	
		break;

	case ADJ_TOKEN:
	
		IScurrentScope.intStart = 69;
		IScurrentScope.intEnd = 107;
		
		break;

	case NOUN_TOKEN:
	
		IScurrentScope.intStart = 108;
		IScurrentScope.intEnd = 127;
	
		break;

	default:
	
		IScurrentScope.intStart = -1;
		IScurrentScope.intEnd = -1;
	
	};

	return IScurrentScope;
}


// add implementation of the function pickRuleRandomly here.
int pickRuleRandomly(const string& THE_TOKEN)
{
	IntScope IScurrentScope = findCategoryScope(THE_TOKEN);

	try
	{
		return (IScurrentScope.intStart + nrand(IScurrentScope.intEnd - IScurrentScope.intStart));
	}
	catch(domain_error)
	{
		return IScurrentScope.intStart;
	}
}

// add implementation of the boolean function isCategoryName here.
bool isCategoryName(const string& ISCATEGORYNAME)
{
	//if the string is a category name return true otherwise return false
	return (ISCATEGORYNAME == MISSION_TOKEN ||
			ISCATEGORYNAME == OURJOB_TOKEN ||
			ISCATEGORYNAME == JOB_TOKEN ||
			ISCATEGORYNAME == DOGOALS_TOKEN ||
			ISCATEGORYNAME == DOGOALS_TOKEN ||
			ISCATEGORYNAME == BECAUSE_TOKEN ||
			ISCATEGORYNAME == GOAL_TOKEN ||
			ISCATEGORYNAME == ADV_TOKEN ||
			ISCATEGORYNAME == VERB_TOKEN ||
			ISCATEGORYNAME == ADJ_TOKEN ||
			ISCATEGORYNAME == NOUN_TOKEN
		    );
}

// add implementation of the function generateSentence here.
string generateSentence(const string& THE_TOKEN)
{
	string strCurrent = "";

	if(isCategoryName(THE_TOKEN))
	{
		int intRule = pickRuleRandomly(THE_TOKEN);

		string* str_arrWord = new string[GRAMMAR[intRule][1].length()];

		int intSize = split(GRAMMAR[intRule][1], str_arrWord, GRAMMAR[intRule][1].length());

		for(int intI = 0; intI < intSize; intI++)
		{
			strCurrent += generateSentence(str_arrWord[intI]);
		}

		delete[] str_arrWord;
	}
	else
		strCurrent = THE_TOKEN + " ";	

	return strCurrent;
}

// This function writes the sentence to a specified file.
// Parameters:
//	1. fileName [in]: the name of the output file
//	2. sent [in]: the sentence to be writen to the file
// Return Value:
//	no return value
// No modification allowed for this function
void printSentence(const string fileName, const string sent )
{
	ofstream		ofs;

	ofs.open( fileName.c_str() );
	if ( !ofs )
	{
		cout << "Cannot open the file " << fileName << endl;
		return;
	}
	ofs << sent;
	if ( !ofs )
		cout << "Error in writing the file " << fileName << endl;
	ofs.close();
	return;
}


